import fs from "fs";
import path from "path";
import { Cel, Layer, Point, Sprite } from "./sprite";
import { celNumberOfPatterns, celSpriteAttrsAndPatterns, tilemapAnchor } from "./cel";

const FRAMES_HEADER_FILE = "frames_def.h";
const SKINS_HEADER_FILE = "skins.h";

/**
 * Produces a set of asm files with the frame definition of all the sprites, together with binary files for its content
 * Asm files are grouped by memory page (8k) starting in the @page parameter.
 * The content includes both the attributes and the patterns
 * Asm files follow the name convention: @asmDir/sprites_page_nn.asm
 * Binary files follow the name convention: @binaryDir/sprites_skin_nn.bin where nn is the frame number
 */
export function writeFrameDefinitions(sprites: Sprite[], page: number, asmDir: string, binaryDir: string, refPoint: Point) {
    const frameDefFiles: FrameDefFile[] = [];
    const skins = sprites.flatMap(sprite => sprite.layers);

    for (const skin of skins) {
        const maxSpritesInSkin = Math.max(...skin.cels.map(cel => cel.tilemap.length));
        for (const cel of skin.cels) {
            const binaryFile = binaryFilename(binaryDir, skin.name, cel.frame.frameIndex, skin.cels.length);
            const data = Buffer.concat(celSpriteAttrsAndPatterns(cel, maxSpritesInSkin));
            fs.writeFileSync(binaryFile, data);

            let defFile = frameDefFiles.find(f => f.fitsInPage(data.length));
            if (!defFile) {
                defFile = new FrameDefFile(page++);
                frameDefFiles.push(defFile);
            }

            const [offsetX, offsetY] = celOffset(cel, refPoint);
            defFile.addFrame({
                nTiles: cel.tilemap.length,
                nPatterns: celNumberOfPatterns(cel),
                offsetX,
                offsetY,
                identifier: `sprite_${skin.name}_${cel.frame.frameIndex}`,
                binary_filename: binaryFile,
                binary_size: data.length,
                skin,
                frameNumber: cel.frame.frameIndex
            });
        }
    }

    const frameDefs = frameDefFiles.flatMap(f => f.frames);

    writeFrameHeaderFile(path.join(asmDir, FRAMES_HEADER_FILE), frameDefs);

    for (const defFile of frameDefFiles) {
        defFile.writeAsmFiles(asmDir);
    }

    writeSkinFile(path.join(asmDir, "skins.c"), frameDefFiles);
    writeSkinHeaderFile(path.join(asmDir, SKINS_HEADER_FILE), skins);
}
interface FrameDefData {
    offsetX: number;
    offsetY: number;
    nTiles: number;
    nPatterns: number;
    identifier: string;
    binary_filename: string;
    binary_size: number;
    skin: Layer;
    frameNumber: number;
}

const FRAMEDEF_OVERHEAD = 3; // 3 additional bytes for nPatterns, offsetX and offsetY
const PAGE_SIZE = 8192;

class FrameDefFile {
    frames: FrameDefData[] = [];

    constructor(public page: number) {
    }

    addFrame(data: FrameDefData) {
        this.frames.push(data);
    }

    memoryUsage() {
        return this.frames.reduce((acc, frame) => acc + frame.binary_size + FRAMEDEF_OVERHEAD, 0);
    }

    fitsInPage(frameSize: number) {
        return this.memoryUsage() + frameSize + FRAMEDEF_OVERHEAD <= PAGE_SIZE;
    }

    writeAsmFiles(asmDir: string) {
        const fileName = asmFilename(asmDir, this.page);
        const fd = fs.openSync(fileName, 'w');
        fs.writeSync(fd, `\tSECTION PAGE_${this.page}\n\n`);
        const symbols = this.frames.map(asm_symbol_name);
        fs.writeSync(fd, `\tPUBLIC ${symbols.join(", ")}\n\n`);

        for (const frame of this.frames) {
            fs.writeSync(fd, `${asm_symbol_name(frame)}:\n`);
            const data = [frame.nPatterns, frame.offsetX, frame.offsetY].map(formatByte);
            fs.writeSync(fd, `\tdb ${data.join(", ")}\n`);
            const binary_ref = composePath(asmDir, frame.binary_filename);
            fs.writeSync(fd, `\tincbin "${binary_ref}"\n\n`);
        }

        fs.closeSync(fd);
    }
}

function writeFrameHeaderFile(filename: string, frames: FrameDefData[]) {
    const fd = fs.openSync(filename, 'w');
    fs.writeSync(fd, "// **** File generated by ase2next ***\n");
    fs.writeSync(fd, "// **** Do not edit ***\n\n");
    fs.writeSync(fd, "#ifndef _FRAMEDEFS_H_\n");
    fs.writeSync(fd, "#define _FRAMEDEFS_H_\n\n");
    fs.writeSync(fd, '#include "unified_sprites.h"\n\n');

    // FrameDefinition
    for (const frame of frames) {
        fs.writeSync(fd, `extern const FrameDefinition ${c_symbol_name(frame)};\n`);
    }

    fs.writeSync(fd, "\n#endif\n");
    fs.closeSync(fd);
}

function patternOffsetBySkin(frames: FrameDefData[]): Map<string, number> {
    const groupsBySkin = groupBy(frames, f => f.skin.name);
    const map = new Map<string, number>();

    let offset = 0;
    for (const [skin, skinFrames] of groupsBySkin) {
        const maxNPatterns = Math.max(...skinFrames.map(f => f.nPatterns));
        map.set(skin, offset);
        offset += maxNPatterns;
    }

    return map;
}


function writeSkinFile(filename: string, frameDefFiles: FrameDefFile[]) {
    const fd = fs.openSync(filename, 'w');
    fs.writeSync(fd, "// **** File generated by ase2next ***\n");
    fs.writeSync(fd, "// **** Do not edit ***\n\n");
    fs.writeSync(fd, `#include "${SKINS_HEADER_FILE}"\n`);
    fs.writeSync(fd, `#include "${FRAMES_HEADER_FILE}"\n\n`);

    // Extract skin, c_symbol, frame number and page from the frame definition files
    const frameInfos = frameDefFiles.flatMap(f => f.frames.map(frame => ({ skin: frame.skin, c_symbol: c_symbol_name(frame), frameNumber: frame.frameNumber, page: f.page, nTiles: frame.nTiles, nPatterns: frame.nPatterns })));

    // Groups by skin
    const skinGroups = groupBy(frameInfos, f => f.skin.name);

    for (const [skin, frameInfo] of skinGroups) {
        const ordFrames = frameInfo.sort((a, b) => a.frameNumber - b.frameNumber);
        const maxTiles = Math.max(...ordFrames.map(f => f.nTiles));
        const maxPatterns = Math.max(...ordFrames.map(f => f.nPatterns));
        fs.writeSync(fd, `const SkinDefinition ${skin_symbol_name(skin)} = {\n`);
        fs.writeSync(fd, `\t.nSprites = ${maxTiles},\n`);
        fs.writeSync(fd, `\t.maxPatterns = ${maxPatterns},\n`);
        fs.writeSync(fd, `\t.nFrames = ${ordFrames.length},\n`);
        fs.writeSync(fd, `\t.frameAddresses = {\n`);
        for (const frame of ordFrames)
            fs.writeSync(fd, `\t\t{${frame.page}, &${frame.c_symbol}},\n`);
        fs.writeSync(fd, "\t}\n");
        fs.writeSync(fd, "};\n\n");
    }

    fs.closeSync(fd);
}

function writeSkinHeaderFile(filename: string, skins: Layer[]) {
    const fd = fs.openSync(filename, 'w');
    fs.writeSync(fd, "// **** File generated by ase2next ***\n");
    fs.writeSync(fd, "// **** Do not edit ***\n\n");
    fs.writeSync(fd, "#ifndef _SKINS_H_\n");
    fs.writeSync(fd, "#define _SKINS_H_\n\n");
    fs.writeSync(fd, '#include "unified_sprites.h"\n\n');
    for (const skin of skins) {
        fs.writeSync(fd, `extern const SkinDefinition ${skin_symbol_name(skin.name)};\n`);
    }
    fs.writeSync(fd, "\n#endif\n");
    fs.closeSync(fd);
}

const header_files = ['"unified_sprites.h"', '<stdint.h>'];
class CFrameDefinitionWriteer {

    private fd: number;

    constructor(name: string) {
        this.fd = fs.openSync(name, 'w');
        this.addHeader();
    }

    private addHeader() {

        fs.writeSync(this.fd, [
            "// **** File generated by ase2next ***\n",
            "// **** Do not edit ***\n\n"].join(''));

        header_files.forEach(element => fs.writeSync(this.fd, `#include ${element}\n`));
        fs.writeSync(this.fd, "\n");
    }


}





function celOffset(cel: Cel, refPoint: Point): [number, number] {
    const absRefPoint = [refPoint[0] * cel.canvasWidth, refPoint[1] * cel.canvasHeight];
    const anchor = tilemapAnchor(cel);
    const anchorPosition = [anchor.x * 16 + cel.xPos, anchor.y * 16 + cel.yPos];
    return [anchorPosition[0] - absRefPoint[0], anchorPosition[1] - absRefPoint[1]];
}


// ================================================================================ //
// File names and naming conventions                                                //
// ================================================================================ //

function binaryFilename(binaryDir: string, skin: string, frameIndex: number, nFrames: number) {
    const skin_filename = skin.replace(/[^a-zA-Z0-9_]/g, '_');
    if (nFrames > 1) {
        const frameIndexStr = frameIndex.toString().padStart(2, '0');
        return `${binaryDir}/sprite_${skin_filename}_${frameIndexStr}.bin`;
    }
    else
        return `${binaryDir}/sprite_${skin_filename}.bin`;
}


function asmFilename(asmDir: string, page: number) {
    const pageStr = page.toString().padStart(2, '0');
    return `${asmDir}/sprites_page_${pageStr}.asm`;
}

function c_symbol_name(frame: FrameDefData) {
    return `${filename_without_extension(frame.binary_filename)}`;
}

function asm_symbol_name(frame: FrameDefData) {
    return `_${c_symbol_name(frame)}`;
}

function skin_symbol_name(name: string) {
    const symbol = name.replace(/[^a-zA-Z0-9_]/g, '_');
    return `skin_${symbol}`;
}


// ================================================================================ //
// Format utils                                                                     //
// ================================================================================ //


function formatByte(value: number): string {
    const byteValue = value & 0xFF; // Ensure the value is treated as an 8-bit value
    return `0x${byteValue.toString(16).padStart(2, "0")}`;
}


// ================================================================================ //
// Path utils                                                                       //
// ================================================================================ //


function filename_without_extension(filename: string) {
    return filename.match(/([^\/\\]+)(?=\.\w+$)/)![0];
}

function composePath(referencePath: string, targetPath: string): string {
    const absoluteReferencePath = path.resolve(referencePath);
    const absoluteTargetPath = path.resolve(targetPath);
    const relativePath = path.relative(absoluteReferencePath, absoluteTargetPath);

    return relativePath.startsWith('.') ? relativePath : `./${relativePath}`;
}


// ================================================================================ //
// General utils                                                                   //
// ================================================================================ //

function groupBy<T, K>(array: T[], key: (item: T) => K): Map<K, T[]> {
    return array.reduce((acc, item) => {
        const k = key(item);
        if (!acc.has(k)) {
            acc.set(k, []);
        }
        acc.get(k)!.push(item);
        return acc;
    }, new Map<K, T[]>());
}

